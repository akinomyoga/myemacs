


;;
;; backtrack を実行するにはどうしたら良いのか?
;; 1 現在の位置と現在の正規表現要素と現在の捕獲を記録する必要がある
;; 2 記録した "正規表現要素" から一致を再開できる必要がある
;;
;; やはり正規表現一致の実装は簡単には行かない。backtrack が厄介である。
;;

;; ■平坦化の手法?
;;   →結局余り得策ではないと判断する
;;
;; a (b|c|d) e の時…状態を平坦にしてしまう?
;; |~  | t           | f     | 
;; | a | (b,$) -     | -     |
;; | b | (e,$) (c,^) | (c,^) |
;; | c | (e,$) (d,^) | (d,^) |
;; | d | (e,$) -     | -     |
;; | e | (T,$) -     | -     |
;;
;; t の列は一致に成功した時の次の一致試行先
;; f の列は一致に失敗した時の次の一致試行先
;; "-" となっている場合は一致試行先がない事 (失敗) を表す
;; (X,Y) の X が次の一致試行の正規表現要素で Y が次の状態に移る時のバッファ内の位置。
;; Y=$ は当該要素の一致後の位置であり、^ は当該要素の一致前の位置である。
;; "t" 欄に二つある場合は 2つ目は backtrack 時の移動先である。
;;
;; a b* c の時も同じ様にできる?
;;
;; - a (b,$)       | -
;; - b (b,$) (c,$) | (c,^)
;; - c (T,$)       | -
;;
;; 任意の要素についてできるか?
;; - a b c → これは順に適用するだけ
;; - a{n} → これも本質的に同じ
;; - a?
;;   (T,$) (T,^) | (T,^)
;; - a*
;;   (a,$) (T,$) | (T,^)
;;   大量のバックトラックを設置する事になり非効率的かもしれない。
;;   a が単純な場合 (.*, [...]* など) にはバックトラックをその場では設定せずに、
;;   復帰した時に設置する様にできるかも。
;; - a{n,} → a{n}a* と同じ
;; - a{,n}
;;   今迄通りには行かない。残り回数 n をパラメータとして次に渡す必要がある。
;;   (a(n-1),$) (T,$) | (T,^) みたいな感じ。
;;   本当にこれで行けるのか? a の内部にある状態は保持されているのか?
;;   ××××××
;; - (?=a)
;;   (T,^) | -
;; - (?!a)
;;   - | (T,^)
;; - (?<!a) (?<=a) これらはちょっと非自明だ。
;;   実装の方針としては "逆方向への一致" を実装するか、
;;   1文字ずつ後退しながら何度も一致を試みるか、の2通りがある。
;;   1文字ずつ後退しながらの方法だとどんなに単純な正規表現 a に対しても
;;   無限に後退しなければならないので×。
;;   逆方向に対する一致の場合、(まともな正規表現を指定すれば)
;;   どう頑張っても一致しないと判定できる点が何れ来る。
;;   逆方向への一致を実装してしまえば、(?<=a) (?<!a) は (?=a) (?!a) と同じである。
;; - (?>a)
;;   これは開始前の backtrack stack の位置を調べておいて
;;   全体が一致した際に backtrack 達を削除してしまえば良い(本当か?)。
;;
;; 結局平坦化によって問題が解決したのかというと難しい。
;; 平坦化は何をしたかというと、
;;   (正規表現要素,全体の状態) |→ 正規表現要素'
;; というマッピングをしただけの事である。
;; これの利点は "全体の状態" という物の形式を考える必要が無く、
;; 全て "正規表現要素'" を指定する一つの整数で表現できてしまう事にある。
;; しかし、特に全体の状態として覚えておく物が多くなってくると、
;; 正規表現要素' の種類は掛け算で増えていくので容易に破綻する。
;; 例 a{0,15}{0,15}{0,15}{0,15}{0,15}{0,15}{0,15}{0,15}
;; →しかしこの様な無茶な正規表現は現実的か?
;; 例: 或いは (xa{0,65536}){0,65536} など?
;; →試しに /^(xa{0,1000000}){0,1000000}$/ を Chrome で試したが普通に動く。
;;   /^(?:=(?:z(?:y(?:xa{0,65536}){0,65536}){0,65536}){0,65536}){0,65536}$/.exec("=zyxaxaaaa") も動く。
;;   平坦化などという方法を用いて状態を作っている訳ではない事は明らか? だ。
;;
;; 平坦化の利点は一致のコードを単純化できるという事である。
;; (様々な要素の一致方法を一般化して扱う事を可能にしている。)
;; しかし、一方で「現在の状態」を別に管理しなければならないのは変わらない。
;;
;; 平坦化の欠点は、制御のフローが固定化されてしまう為に、
;; 再帰的な表現などを取り扱う事が出来なくなる事である (正規表現を超えているが)。
;; "戻り先の正規表現要素" も状態に含める事でこれは実現できる。
;; 何だかんだで結局現在の C++ 実装に近くなる気もする。
;;
;; ■
;; [[正規表現エンジンを作ろう （6） （3/3）：CodeZine>http://codezine.jp/article/detail/3188?p=3]]
;; ここに Henry Spencer の正規表現を デバグモードでコンパイルして ./try をすると、
;; コンパイルされた正規表現のバイトコードが見られると書いてある。
;; これで a* だとか a{0,100} だとかを見るとどうなるか試すのも良いだろう。
;;

(defun mwg-rex/match-forward-string (str &optional pt)
  (let ((p (or pt (point)))
        (pN (point-max))
        (i 0)
        (iN (length str)))
    (while (and (< i iN)
                (< p pN)
                (= (char-after p) (aref str i)))
      (setq i (1+ i) p (1+ p)))
    (if (= i iN) p)))
(defun mwg-rex/match-forward-or (lst)
  )

;; backtrack を覚えておく必要がある
(defun mwg-rex/match (rexp)
  (pcase rexp
    ((pred stringp)
     (mwg-rex/match-forward-string rexp))
    (`(char ,ch)
     (when (if (integerp ch)
               (= ch (char-after))
             (funcall cpred (char-after)))
       (forward-char 1)
       (point)))
    (`(or . ,list)
     
     )

    ))
